#!groovy

def evLibrary = library(identifier: 'evernym-aws-codebuild@aws-codebuild', retriever: modernSCM(
    github(credentialsId: 'evernym-github-machine-user', repoOwner: 'evernym', repository: 'jenkins-shared')
)).com.evernym.pipeline

logger = evLibrary.Logger.new(this)
notifier = evLibrary.Notifier.new(this)
logger.setGlobalLevel('TRACE')

pipelineWrapper({

    nodeWrapper {
        def osname = 'xenial'
        List projects = [['sovtoken', 'sovtoken'], ['sovtoken_fees', 'sovtoken_fees']]

        stage('Checkout sources from SCM') {
            checkout scm
        }

        def evernymRepo = evLibrary.EvernymRepo.new(this)
        def utils = evLibrary.Utils.new(this)
        def buildCtx = evLibrary.AwsCodeBuildHelper.BuildCtx.new('plugin',
            ['devops', 'sovtoken/__metadata__.py', 'sovtoken_fees/__metadata__.py'])
        def awsCBHelper = evLibrary.AwsCodeBuildHelper.new(this, buildCtx)


        stage('Upload source to S3') {
            awsCBHelper.uploadSourceToS3()
        }

        Map builds = projects.collectEntries {
            def proj = it[0]
            def packageName = it[1]

            ["$proj:$osname": {

                def srcVersion
                def lastRevision
                def debPVersion
                def goals = ['package']

                def ciImageTag
                def osname = 'xenial'

                def ciImageTag

                stage('Resolve current source version') {
                    // TODO
                    srcVersion = '0.1.0'
                    //utils.srcVersion(projectType: 'rust')
                    logger.info("Current source version: $srcVersion")
                }

                stage('Resolve last revision') {
                    lastRevision = evernymRepo.getLastRevision {
                        delegate.packageName = packageName
                        packageSrcVersion = srcVersion
                        repoDistr = 'agency-dev'
                    }

                    if (lastRevision) {
                        logger.info("Found last revision number: $lastRevision")
                    } else {
                        logger.info("No previous revision was found")
                    }
                }

                stage('Set release parameters') {
                    def releaseVersion = "${lastRevision ? lastRevision[0] + 1: 1}.$BUILD_NUMBER"

                    debPVersion = utils.packageVersion('deb-kraken', srcVersion, releaseVersion)
                    logger.info("Package version for evernym repo: $debPVersion")

                    // TODO crate and rpm
                    //cratePVersion = utils.packageVersion('crate', srcVersion, releaseVersion)
                    //logger.info("Package version for rust registry: $cratePVersion")
                }

                stage("$osname:$proj: Resolve image tag") {
                    def _imgVersion = utils.shStdout("OSNAME=$osname make -C devops image_ci_version -s")
                    ciImageTag = "$_imgVersion-$osname-$proj-ci"
                    logger.info("CI docker image tag: $ciImageTag")
                }

                awsCBHelper.build() {
                    projectTag = "ci-$osname-$proj" // use ci project

                    // TODO shouldn't create/update CodeBuild project assuming that CI did this before
                    // and no changes in settings have appeared

                    // env and build spec
                    imageTag = ciImageTag
                    buildspec = 'devops/aws-codebuild/buildspec.yml'
                    envv = [
                        [name: 'OSNAME', value: osname],
                        [name: 'MAKE_GOALS', value: 'package'],
                        [name: 'SRC_DIR_NAME', value: proj],
                        [name: 'ARTIFACTS', value: "_build/$proj/*$packageName*.*"], // TODO more accurate here
                        [name: 'FPM_P_VERSION', value: debPVersion],
                    ]

                    onArtifacts = {
                        this.stage("$osname:$proj: Archive logs") {
                            utils.archiveArtifacts("logs/*.out*") {
                                truncate = true
                                allowEmptyArchive = true
                            }
                        }
                    }
                }

                stage('Upload deb to Evernym repo') {
                    String debName

                    dir("${awsCBHelper.buildCtx.projects[prTag].artifactsDir}") {
                        debName = utils.shStdout("ls $packageName*$debPVersion*.deb")

                        logger.info("Uploading debian package '$debName' to evernym repo")
                        evernymRepo.upload {
                            repoDistr = 'agency_dev'
                            packagePath = debName
                        }
                    }

                    notifier.email {
                        subject = '$PROJECT_NAME - Build # $BUILD_NUMBER: ' + "new deb '$debName' was published"
                        body = ("New debian package '$debName' was built and published" +
                            '\n\nCheck console output at $BUILD_URL to view the results.')
                    }
                }

            }]
        }
    }
}, { err ->
    if (err) {
        logger.error("Pipeline failed with the error $err")
    }

    stage("Build result notification") {
        notifier.email()
    }
})
